// Package hawksoft provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package hawksoft

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for LogNoteChannel.
const (
	LogNoteChannelEmail    LogNoteChannel = "Email"
	LogNoteChannelFax      LogNoteChannel = "Fax"
	LogNoteChannelInPerson LogNoteChannel = "InPerson"
	LogNoteChannelMail     LogNoteChannel = "Mail"
	LogNoteChannelOther    LogNoteChannel = "Other"
	LogNoteChannelPhone    LogNoteChannel = "Phone"
)

// Defines values for ReceiptChannel.
const (
	ReceiptChannelEmail    ReceiptChannel = "Email"
	ReceiptChannelFax      ReceiptChannel = "Fax"
	ReceiptChannelInPerson ReceiptChannel = "InPerson"
	ReceiptChannelMail     ReceiptChannel = "Mail"
	ReceiptChannelOther    ReceiptChannel = "Other"
	ReceiptChannelPhone    ReceiptChannel = "Phone"
)

// Defines values for TaskAssignmentAssignedToRole.
const (
	AccountManager TaskAssignmentAssignedToRole = "AccountManager"
	CSR            TaskAssignmentAssignedToRole = "CSR"
	Producer       TaskAssignmentAssignedToRole = "Producer"
	SpecifiedUser  TaskAssignmentAssignedToRole = "SpecifiedUser"
	Underwriter    TaskAssignmentAssignedToRole = "Underwriter"
)

// Defines values for VersionParam.
const (
	VersionParamN30 VersionParam = "3.0"
)

// Defines values for GetAgenciesParamsVersion.
const (
	GetAgenciesParamsVersionN30 GetAgenciesParamsVersion = "3.0"
)

// Defines values for GetClientParamsVersion.
const (
	GetClientParamsVersionN30 GetClientParamsVersion = "3.0"
)

// Defines values for GetClientParamsInclude.
const (
	GetClientParamsIncludeClaims   GetClientParamsInclude = "Claims"
	GetClientParamsIncludeContacts GetClientParamsInclude = "Contacts"
	GetClientParamsIncludeDetails  GetClientParamsInclude = "Details"
	GetClientParamsIncludeInvoices GetClientParamsInclude = "Invoices"
	GetClientParamsIncludePeople   GetClientParamsInclude = "People"
	GetClientParamsIncludePolicies GetClientParamsInclude = "Policies"
)

// Defines values for UploadAttachmentParamsVersion.
const (
	UploadAttachmentParamsVersionN30 UploadAttachmentParamsVersion = "3.0"
)

// Defines values for CreateLogNoteParamsVersion.
const (
	CreateLogNoteParamsVersionN30 CreateLogNoteParamsVersion = "3.0"
)

// Defines values for CreateReceiptsParamsVersion.
const (
	CreateReceiptsParamsVersionN30 CreateReceiptsParamsVersion = "3.0"
)

// Defines values for GetChangedClientsParamsVersion.
const (
	GetChangedClientsParamsVersionN30 GetChangedClientsParamsVersion = "3.0"
)

// Defines values for GetClientListParamsVersion.
const (
	GetClientListParamsVersionN30 GetClientListParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsVersion.
const (
	SearchClientsParamsVersionN30 SearchClientsParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsInclude.
const (
	SearchClientsParamsIncludeClaims   SearchClientsParamsInclude = "Claims"
	SearchClientsParamsIncludeContacts SearchClientsParamsInclude = "Contacts"
	SearchClientsParamsIncludeDetails  SearchClientsParamsInclude = "Details"
	SearchClientsParamsIncludeInvoices SearchClientsParamsInclude = "Invoices"
	SearchClientsParamsIncludePeople   SearchClientsParamsInclude = "People"
	SearchClientsParamsIncludePolicies SearchClientsParamsInclude = "Policies"
)

// Defines values for GetAgencyOfficesParamsVersion.
const (
	GetAgencyOfficesParamsVersionN30 GetAgencyOfficesParamsVersion = "3.0"
)

// Agency Agency ID
type Agency = int

// Claim defines model for Claim.
type Claim struct {
	// ClaimNumber Claim number (optional)
	ClaimNumber *string `json:"ClaimNumber,omitempty"`

	// ClaimStatus Claim status enum (required)
	ClaimStatus string `json:"ClaimStatus"`

	// LossAmount Loss amount (optional)
	LossAmount *float64 `json:"LossAmount,omitempty"`

	// LossDate Loss date (optional)
	LossDate *time.Time `json:"LossDate,omitempty"`

	// PolicyNumber Associated policy number (optional)
	PolicyNumber *string `json:"PolicyNumber,omitempty"`
}

// ClientData Complete client information with optional includes
type ClientData struct {
	// Claims Claims associated with the client (required)
	Claims []Claim `json:"Claims"`

	// ClientNumber Client number (required)
	ClientNumber int32 `json:"ClientNumber"`

	// Contacts Contact information (required)
	Contacts []Contact     `json:"Contacts"`
	Details  ClientDetails `json:"Details"`

	// Invoices Invoices (optional, requires include parameter)
	Invoices *[]Invoice `json:"Invoices,omitempty"`

	// People People associated with the client (required)
	People []Person `json:"People"`

	// Policies Policies associated with the client (required)
	Policies []Policy `json:"Policies"`
}

// ClientDetails defines model for ClientDetails.
type ClientDetails struct {
	// AgencyNum Agency number (optional)
	AgencyNum *string `json:"AgencyNum,omitempty"`

	// BusinessType Business type enum (optional)
	BusinessType *string `json:"BusinessType,omitempty"`

	// ClientType Client type enum (required)
	ClientType string `json:"ClientType"`

	// CompanyName Company name for commercial clients (optional)
	CompanyName *string `json:"CompanyName,omitempty"`

	// IsCommercial Whether this is a commercial client (required)
	IsCommercial bool `json:"IsCommercial"`

	// IsPersonal Whether this is a personal client (required)
	IsPersonal bool `json:"IsPersonal"`

	// Status Client status enum (required)
	Status string `json:"Status"`
}

// ClientSummary Summary information for changed clients
type ClientSummary struct {
	// ClientNumber Client number
	ClientNumber *int32 `json:"ClientNumber,omitempty"`

	// Deleted Whether the client has been deleted
	Deleted *bool `json:"Deleted,omitempty"`

	// LastModified Last modification timestamp
	LastModified *time.Time `json:"LastModified,omitempty"`
}

// Contact defines model for Contact.
type Contact struct {
	// Data Contact data (phone, email, etc.) (required)
	Data string `json:"Data"`

	// IsBillingContact Whether this is a billing contact (required)
	IsBillingContact bool `json:"IsBillingContact"`

	// PersonId GUID of associated person (optional)
	PersonId *openapi_types.UUID `json:"PersonId,omitempty"`

	// Type Contact type enum (required)
	Type string `json:"Type"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code *string `json:"code,omitempty"`

	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	// Balance Invoice balance (required)
	Balance float64 `json:"Balance"`

	// Date Invoice date (required)
	Date openapi_types.Date `json:"Date"`

	// DueDate Invoice due date (required)
	DueDate openapi_types.Date `json:"DueDate"`

	// InvoiceNumber Invoice number (required)
	InvoiceNumber string `json:"InvoiceNumber"`

	// Total Invoice total amount (required)
	Total float64 `json:"Total"`
}

// LOB Line of Business
type LOB struct {
	// Code LOB code
	Code *string `json:"Code,omitempty"`

	// Name LOB name
	Name *string `json:"Name,omitempty"`
}

// LogNote defines model for LogNote.
type LogNote struct {
	// Channel Log action channel/type (LogAction enum)
	Channel LogNoteChannel `json:"Channel"`

	// Note The log note content
	Note string `json:"Note"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`
	Task     *TaskAssignment     `json:"Task,omitempty"`
}

// LogNoteChannel Log action channel/type (LogAction enum)
type LogNoteChannel string

// Office defines model for Office.
type Office struct {
	// AddressLine1 Street address line 1
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Street address line 2
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// City City
	City *string `json:"City,omitempty"`

	// OfficeDescription Office description or name
	OfficeDescription *string `json:"OfficeDescription,omitempty"`

	// OfficeId Unique office identifier
	OfficeId *int `json:"OfficeId,omitempty"`

	// PrimaryOffice Whether this is the primary office
	PrimaryOffice *bool `json:"PrimaryOffice,omitempty"`

	// State State or province
	State *string `json:"State,omitempty"`

	// SubAgencyName Sub-agency name
	SubAgencyName *string `json:"SubAgencyName,omitempty"`

	// Zipcode ZIP or postal code
	Zipcode *string `json:"Zipcode,omitempty"`
}

// Person defines model for Person.
type Person struct {
	// DateOfBirth Date of birth (optional)
	DateOfBirth *time.Time `json:"DateOfBirth,omitempty"`

	// FirstName First name (optional)
	FirstName *string `json:"FirstName,omitempty"`

	// Gender Gender enum (required)
	Gender string `json:"Gender"`

	// LastName Last name (optional)
	LastName *string `json:"LastName,omitempty"`

	// Occupation Occupation (optional)
	Occupation *string `json:"Occupation,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	// AccountNumber Account number (optional)
	AccountNumber *string `json:"AccountNumber,omitempty"`

	// Carrier Insurance carrier (required)
	Carrier string `json:"Carrier"`

	// EffectiveDate Policy effective date (optional)
	EffectiveDate *time.Time `json:"EffectiveDate,omitempty"`

	// ExpirationDate Policy expiration date (optional)
	ExpirationDate *time.Time `json:"ExpirationDate,omitempty"`

	// LOBs Lines of business (required)
	LOBs []LOB `json:"LOBs"`

	// PolicyNumber Policy number (optional)
	PolicyNumber *string `json:"PolicyNumber,omitempty"`

	// Premium Policy premium amount (optional)
	Premium *float64 `json:"Premium,omitempty"`

	// Status Policy status enum (required)
	Status string `json:"Status"`

	// Type Policy type enum (required)
	Type string `json:"Type"`
}

// Receipt defines model for Receipt.
type Receipt struct {
	// Channel Source of interaction (LogAction enum, required)
	Channel ReceiptChannel `json:"Channel"`

	// Invoices Invoices being paid (required)
	Invoices []ReceiptInvoiceItem `json:"Invoices"`

	// LogNote Payment log note (optional)
	LogNote *string `json:"LogNote,omitempty"`

	// OfficeId Payment's office ID (optional)
	OfficeId *int `json:"OfficeId,omitempty"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`

	// RefId Unique ID for the receipt (required)
	RefId openapi_types.UUID `json:"RefId"`

	// TS Payment received timestamp (required)
	TS   time.Time       `json:"TS"`
	Task *TaskAssignment `json:"Task,omitempty"`

	// Total Total payment amount
	Total *float64 `json:"Total,omitempty"`
}

// ReceiptChannel Source of interaction (LogAction enum, required)
type ReceiptChannel string

// ReceiptInvoiceItem defines model for ReceiptInvoiceItem.
type ReceiptInvoiceItem struct {
	// Amount Amount being paid towards this invoice (required)
	Amount float64 `json:"Amount"`

	// InvoiceId Invoice GUID (required)
	InvoiceId openapi_types.UUID `json:"InvoiceId"`
}

// TaskAssignment defines model for TaskAssignment.
type TaskAssignment struct {
	// AssignedToEmail Email address (required if AssignedToRole is SpecifiedUser)
	AssignedToEmail *openapi_types.Email `json:"AssignedToEmail,omitempty"`

	// AssignedToRole Role to assign task to
	AssignedToRole *TaskAssignmentAssignedToRole `json:"AssignedToRole,omitempty"`

	// Description Task description
	Description *string `json:"Description,omitempty"`

	// DueDate Task due date
	DueDate *time.Time `json:"DueDate,omitempty"`

	// Title Task title
	Title *string `json:"Title,omitempty"`
}

// TaskAssignmentAssignedToRole Role to assign task to
type TaskAssignmentAssignedToRole string

// AgencyIdParam defines model for AgencyIdParam.
type AgencyIdParam = string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// ClientIncludesParam defines model for ClientIncludesParam.
type ClientIncludesParam = []string

// VersionParam defines model for VersionParam.
type VersionParam string

// NotFoundError defines model for NotFoundError.
type NotFoundError = Error

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError = Error

// GetAgenciesParams defines parameters for GetAgencies.
type GetAgenciesParams struct {
	// Version API version (must be 3.0)
	Version GetAgenciesParamsVersion `form:"version" json:"version"`
}

// GetAgenciesParamsVersion defines parameters for GetAgencies.
type GetAgenciesParamsVersion string

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Version API version (must be 3.0)
	Version GetClientParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`
}

// GetClientParamsVersion defines parameters for GetClient.
type GetClientParamsVersion string

// GetClientParamsInclude defines parameters for GetClient.
type GetClientParamsInclude string

// UploadAttachmentMultipartBody defines parameters for UploadAttachment.
type UploadAttachmentMultipartBody struct {
	// File The file to upload
	File openapi_types.File `json:"file"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// Version API version (must be 3.0)
	Version UploadAttachmentParamsVersion `form:"version" json:"version"`

	// RefId Reference ID for the attachment
	RefId string `json:"RefId"`

	// Timestamp Timestamp of the attachment
	Timestamp time.Time `json:"Timestamp"`

	// Filename Name of the file being uploaded
	Filename string `json:"Filename"`

	// FileExtension File extension
	FileExtension string `json:"FileExtension"`

	// AssignTask Whether to assign this as a task
	AssignTask *bool `json:"AssignTask,omitempty"`

	// AssignedTo User to assign task to
	AssignedTo *string `json:"AssignedTo,omitempty"`

	// DueDate Task due date if assigned
	DueDate *time.Time `json:"DueDate,omitempty"`
}

// UploadAttachmentParamsVersion defines parameters for UploadAttachment.
type UploadAttachmentParamsVersion string

// CreateLogNoteParams defines parameters for CreateLogNote.
type CreateLogNoteParams struct {
	// Version API version (must be 3.0)
	Version CreateLogNoteParamsVersion `form:"version" json:"version"`
}

// CreateLogNoteParamsVersion defines parameters for CreateLogNote.
type CreateLogNoteParamsVersion string

// CreateReceiptsJSONBody defines parameters for CreateReceipts.
type CreateReceiptsJSONBody = []Receipt

// CreateReceiptsParams defines parameters for CreateReceipts.
type CreateReceiptsParams struct {
	// Version API version (must be 3.0)
	Version CreateReceiptsParamsVersion `form:"version" json:"version"`
}

// CreateReceiptsParamsVersion defines parameters for CreateReceipts.
type CreateReceiptsParamsVersion string

// GetChangedClientsParams defines parameters for GetChangedClients.
type GetChangedClientsParams struct {
	// Version API version (must be 3.0)
	Version GetChangedClientsParamsVersion `form:"version" json:"version"`

	// AsOf Return clients changed since this datetime (optional)
	AsOf *time.Time `form:"asOf,omitempty" json:"asOf,omitempty"`

	// Deleted Include deleted clients
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`
}

// GetChangedClientsParamsVersion defines parameters for GetChangedClients.
type GetChangedClientsParamsVersion string

// GetClientListJSONBody defines parameters for GetClientList.
type GetClientListJSONBody struct {
	// ClientNumbers Array of client numbers to retrieve
	ClientNumbers *[]string `json:"clientNumbers,omitempty"`
}

// GetClientListParams defines parameters for GetClientList.
type GetClientListParams struct {
	// Version API version (must be 3.0)
	Version GetClientListParamsVersion `form:"version" json:"version"`
}

// GetClientListParamsVersion defines parameters for GetClientList.
type GetClientListParamsVersion string

// SearchClientsParams defines parameters for SearchClients.
type SearchClientsParams struct {
	// Version API version (must be 3.0)
	Version SearchClientsParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`

	// PolicyNumber Policy number to search for
	PolicyNumber *string `form:"policyNumber,omitempty" json:"policyNumber,omitempty"`
}

// SearchClientsParamsVersion defines parameters for SearchClients.
type SearchClientsParamsVersion string

// SearchClientsParamsInclude defines parameters for SearchClients.
type SearchClientsParamsInclude string

// GetAgencyOfficesParams defines parameters for GetAgencyOffices.
type GetAgencyOfficesParams struct {
	// Version API version (must be 3.0)
	Version GetAgencyOfficesParamsVersion `form:"version" json:"version"`
}

// GetAgencyOfficesParamsVersion defines parameters for GetAgencyOffices.
type GetAgencyOfficesParamsVersion string

// UploadAttachmentMultipartRequestBody defines body for UploadAttachment for multipart/form-data ContentType.
type UploadAttachmentMultipartRequestBody UploadAttachmentMultipartBody

// CreateLogNoteJSONRequestBody defines body for CreateLogNote for application/json ContentType.
type CreateLogNoteJSONRequestBody = LogNote

// CreateReceiptsJSONRequestBody defines body for CreateReceipts for application/json ContentType.
type CreateReceiptsJSONRequestBody = CreateReceiptsJSONBody

// GetClientListJSONRequestBody defines body for GetClientList for application/json ContentType.
type GetClientListJSONRequestBody GetClientListJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAgencies request
	GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAttachmentWithBody request with any body
	UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogNoteWithBody request with any body
	CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReceiptsWithBody request with any body
	CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChangedClients request
	GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientListWithBody request with any body
	GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClients request
	SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgencyOffices request
	GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, agencyId, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAttachmentRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangedClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequestWithBody(c.Server, agencyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequest(c.Server, agencyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgencyOfficesRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAgenciesRequest generates requests for GetAgencies
func NewGetAgenciesRequest(server string, params *GetAgenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadAttachmentRequestWithBody generates requests for UploadAttachment with any type of body
func NewUploadAttachmentRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/attachment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "RefId", runtime.ParamLocationHeader, params.RefId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("RefId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Timestamp", runtime.ParamLocationHeader, params.Timestamp)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Timestamp", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Filename", runtime.ParamLocationHeader, params.Filename)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Filename", headerParam2)

		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "FileExtension", runtime.ParamLocationHeader, params.FileExtension)
		if err != nil {
			return nil, err
		}

		req.Header.Set("FileExtension", headerParam3)

		if params.AssignTask != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "AssignTask", runtime.ParamLocationHeader, *params.AssignTask)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignTask", headerParam4)
		}

		if params.AssignedTo != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "AssignedTo", runtime.ParamLocationHeader, *params.AssignedTo)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignedTo", headerParam5)
		}

		if params.DueDate != nil {
			var headerParam6 string

			headerParam6, err = runtime.StyleParamWithLocation("simple", false, "DueDate", runtime.ParamLocationHeader, *params.DueDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("DueDate", headerParam6)
		}

	}

	return req, nil
}

// NewCreateLogNoteRequest calls the generic CreateLogNote builder with application/json body
func NewCreateLogNoteRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogNoteRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateLogNoteRequestWithBody generates requests for CreateLogNote with any type of body
func NewCreateLogNoteRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/log", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateReceiptsRequest calls the generic CreateReceipts builder with application/json body
func NewCreateReceiptsRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReceiptsRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateReceiptsRequestWithBody generates requests for CreateReceipts with any type of body
func NewCreateReceiptsRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/receipts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChangedClientsRequest generates requests for GetChangedClients
func NewGetChangedClientsRequest(server string, agencyId AgencyIdParam, params *GetChangedClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AsOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asOf", runtime.ParamLocationQuery, *params.AsOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientListRequest calls the generic GetClientList builder with application/json body
func NewGetClientListRequest(server string, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetClientListRequestWithBody(server, agencyId, params, "application/json", bodyReader)
}

// NewGetClientListRequestWithBody generates requests for GetClientList with any type of body
func NewGetClientListRequestWithBody(server string, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsRequest generates requests for SearchClients
func NewSearchClientsRequest(server string, agencyId AgencyIdParam, params *SearchClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyNumber", runtime.ParamLocationQuery, *params.PolicyNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgencyOfficesRequest generates requests for GetAgencyOffices
func NewGetAgencyOfficesRequest(server string, agencyId AgencyIdParam, params *GetAgencyOfficesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/offices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAgenciesWithResponse request
	GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UploadAttachmentWithBodyWithResponse request with any body
	UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error)

	// CreateLogNoteWithBodyWithResponse request with any body
	CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	// CreateReceiptsWithBodyWithResponse request with any body
	CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	// GetChangedClientsWithResponse request
	GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error)

	// GetClientListWithBodyWithResponse request with any body
	GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	// SearchClientsWithResponse request
	SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error)

	// GetAgencyOfficesWithResponse request
	GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error)
}

type GetAgenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agency
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetAgenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UploadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateLogNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReceiptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateReceiptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReceiptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangedClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientSummary
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetChangedClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangedClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientSummary
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r SearchClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgencyOfficesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Office
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAgencyOfficesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgencyOfficesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAgenciesWithResponse request returning *GetAgenciesResponse
func (c *ClientWithResponses) GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error) {
	rsp, err := c.GetAgencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgenciesResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, agencyId, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UploadAttachmentWithBodyWithResponse request with arbitrary body returning *UploadAttachmentResponse
func (c *ClientWithResponses) UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error) {
	rsp, err := c.UploadAttachmentWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAttachmentResponse(rsp)
}

// CreateLogNoteWithBodyWithResponse request with arbitrary body returning *CreateLogNoteResponse
func (c *ClientWithResponses) CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNoteWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

func (c *ClientWithResponses) CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNote(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

// CreateReceiptsWithBodyWithResponse request with arbitrary body returning *CreateReceiptsResponse
func (c *ClientWithResponses) CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceiptsWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

func (c *ClientWithResponses) CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceipts(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

// GetChangedClientsWithResponse request returning *GetChangedClientsResponse
func (c *ClientWithResponses) GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error) {
	rsp, err := c.GetChangedClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangedClientsResponse(rsp)
}

// GetClientListWithBodyWithResponse request with arbitrary body returning *GetClientListResponse
func (c *ClientWithResponses) GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientListWithBody(ctx, agencyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

func (c *ClientWithResponses) GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientList(ctx, agencyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

// SearchClientsWithResponse request returning *SearchClientsResponse
func (c *ClientWithResponses) SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error) {
	rsp, err := c.SearchClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsResponse(rsp)
}

// GetAgencyOfficesWithResponse request returning *GetAgencyOfficesResponse
func (c *ClientWithResponses) GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error) {
	rsp, err := c.GetAgencyOffices(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgencyOfficesResponse(rsp)
}

// ParseGetAgenciesResponse parses an HTTP response from a GetAgenciesWithResponse call
func ParseGetAgenciesResponse(rsp *http.Response) (*GetAgenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadAttachmentResponse parses an HTTP response from a UploadAttachmentWithResponse call
func ParseUploadAttachmentResponse(rsp *http.Response) (*UploadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateLogNoteResponse parses an HTTP response from a CreateLogNoteWithResponse call
func ParseCreateLogNoteResponse(rsp *http.Response) (*CreateLogNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReceiptsResponse parses an HTTP response from a CreateReceiptsWithResponse call
func ParseCreateReceiptsResponse(rsp *http.Response) (*CreateReceiptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReceiptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChangedClientsResponse parses an HTTP response from a GetChangedClientsWithResponse call
func ParseGetChangedClientsResponse(rsp *http.Response) (*GetChangedClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangedClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClientListResponse parses an HTTP response from a GetClientListWithResponse call
func ParseGetClientListResponse(rsp *http.Response) (*GetClientListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchClientsResponse parses an HTTP response from a SearchClientsWithResponse call
func ParseSearchClientsResponse(rsp *http.Response) (*SearchClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAgencyOfficesResponse parses an HTTP response from a GetAgencyOfficesWithResponse call
func ParseGetAgencyOfficesResponse(rsp *http.Response) (*GetAgencyOfficesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgencyOfficesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Office
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/XcAAAD//4lHpa8VQgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
