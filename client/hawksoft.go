// Package hawksoft provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package hawksoft

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for LogNoteChannel.
const (
	LogNoteChannelEmail    LogNoteChannel = "Email"
	LogNoteChannelFax      LogNoteChannel = "Fax"
	LogNoteChannelInPerson LogNoteChannel = "InPerson"
	LogNoteChannelMail     LogNoteChannel = "Mail"
	LogNoteChannelOther    LogNoteChannel = "Other"
	LogNoteChannelPhone    LogNoteChannel = "Phone"
)

// Defines values for ReceiptChannel.
const (
	ReceiptChannelEmail    ReceiptChannel = "Email"
	ReceiptChannelFax      ReceiptChannel = "Fax"
	ReceiptChannelInPerson ReceiptChannel = "InPerson"
	ReceiptChannelMail     ReceiptChannel = "Mail"
	ReceiptChannelOther    ReceiptChannel = "Other"
	ReceiptChannelPhone    ReceiptChannel = "Phone"
)

// Defines values for TaskAssignmentAssignedToRole.
const (
	AccountManager TaskAssignmentAssignedToRole = "AccountManager"
	CSR            TaskAssignmentAssignedToRole = "CSR"
	Producer       TaskAssignmentAssignedToRole = "Producer"
	SpecifiedUser  TaskAssignmentAssignedToRole = "SpecifiedUser"
	Underwriter    TaskAssignmentAssignedToRole = "Underwriter"
)

// Defines values for VersionParam.
const (
	VersionParamN30 VersionParam = "3.0"
)

// Defines values for GetAgenciesParamsVersion.
const (
	GetAgenciesParamsVersionN30 GetAgenciesParamsVersion = "3.0"
)

// Defines values for GetClientParamsVersion.
const (
	GetClientParamsVersionN30 GetClientParamsVersion = "3.0"
)

// Defines values for GetClientParamsInclude.
const (
	GetClientParamsIncludeClaims   GetClientParamsInclude = "Claims"
	GetClientParamsIncludeContacts GetClientParamsInclude = "Contacts"
	GetClientParamsIncludeDetails  GetClientParamsInclude = "Details"
	GetClientParamsIncludeInvoices GetClientParamsInclude = "Invoices"
	GetClientParamsIncludePeople   GetClientParamsInclude = "People"
	GetClientParamsIncludePolicies GetClientParamsInclude = "Policies"
)

// Defines values for UploadAttachmentParamsVersion.
const (
	UploadAttachmentParamsVersionN30 UploadAttachmentParamsVersion = "3.0"
)

// Defines values for CreateLogNoteParamsVersion.
const (
	CreateLogNoteParamsVersionN30 CreateLogNoteParamsVersion = "3.0"
)

// Defines values for CreateReceiptsParamsVersion.
const (
	CreateReceiptsParamsVersionN30 CreateReceiptsParamsVersion = "3.0"
)

// Defines values for GetChangedClientsParamsVersion.
const (
	GetChangedClientsParamsVersionN30 GetChangedClientsParamsVersion = "3.0"
)

// Defines values for GetClientListParamsVersion.
const (
	GetClientListParamsVersionN30 GetClientListParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsVersion.
const (
	SearchClientsParamsVersionN30 SearchClientsParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsInclude.
const (
	SearchClientsParamsIncludeClaims   SearchClientsParamsInclude = "Claims"
	SearchClientsParamsIncludeContacts SearchClientsParamsInclude = "Contacts"
	SearchClientsParamsIncludeDetails  SearchClientsParamsInclude = "Details"
	SearchClientsParamsIncludeInvoices SearchClientsParamsInclude = "Invoices"
	SearchClientsParamsIncludePeople   SearchClientsParamsInclude = "People"
	SearchClientsParamsIncludePolicies SearchClientsParamsInclude = "Policies"
)

// Defines values for GetAgencyOfficesParamsVersion.
const (
	GetAgencyOfficesParamsVersionN30 GetAgencyOfficesParamsVersion = "3.0"
)

// Agency Agency ID
type Agency = int

// Claim defines model for Claim.
type Claim struct {
	// ClaimNumber Claim number (optional)
	ClaimNumber *string `json:"ClaimNumber,omitempty"`

	// ClaimStatus Claim status enum (required)
	ClaimStatus string `json:"ClaimStatus"`

	// LossAmount Loss amount (optional)
	LossAmount *float64 `json:"LossAmount,omitempty"`

	// LossDate Loss date in format 2024-10-08T00:00:00 (optional)
	LossDate *string `json:"LossDate,omitempty"`

	// PolicyNumber Associated policy number (optional)
	PolicyNumber *string `json:"PolicyNumber,omitempty"`
}

// ClientData Complete client information with optional includes
type ClientData struct {
	// Claims Claims associated with the client (required)
	Claims []Claim `json:"Claims"`

	// ClientNumber Client number (required)
	ClientNumber int32 `json:"ClientNumber"`

	// Contacts Contact information (required)
	Contacts []Contact     `json:"Contacts"`
	Details  ClientDetails `json:"Details"`

	// Invoices Invoices (optional, requires include parameter)
	Invoices *[]Invoice `json:"Invoices,omitempty"`

	// People People associated with the client (required)
	People []Person `json:"People"`

	// Policies Policies associated with the client (required)
	Policies []Policy `json:"Policies"`
}

// ClientDetails defines model for ClientDetails.
type ClientDetails struct {
	// AgencyNum Agency number (optional)
	AgencyNum *string `json:"AgencyNum,omitempty"`

	// BusinessType Business type enum (optional)
	BusinessType *string `json:"BusinessType,omitempty"`

	// ClientType Client type enum (required)
	ClientType string `json:"ClientType"`

	// CompanyName Company name for commercial clients (optional)
	CompanyName *string `json:"CompanyName,omitempty"`

	// IsCommercial Whether this is a commercial client (required)
	IsCommercial bool `json:"IsCommercial"`

	// IsPersonal Whether this is a personal client (required)
	IsPersonal bool `json:"IsPersonal"`

	// Status Client status enum (required)
	Status string `json:"Status"`
}

// Contact defines model for Contact.
type Contact struct {
	// Data Contact data (phone, email, etc.) (required)
	Data string `json:"Data"`

	// IsBillingContact Whether this is a billing contact (required)
	IsBillingContact bool `json:"IsBillingContact"`

	// PersonId GUID of associated person (optional)
	PersonId *openapi_types.UUID `json:"PersonId,omitempty"`

	// Type Contact type enum (required)
	Type string `json:"Type"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code *string `json:"code,omitempty"`

	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	// Balance Invoice balance (required)
	Balance float64 `json:"Balance"`

	// Date Invoice date (required)
	Date openapi_types.Date `json:"Date"`

	// DueDate Invoice due date (required)
	DueDate openapi_types.Date `json:"DueDate"`

	// InvoiceNumber Invoice number (required)
	InvoiceNumber string `json:"InvoiceNumber"`

	// Total Invoice total amount (required)
	Total float64 `json:"Total"`
}

// LOB Line of Business
type LOB struct {
	// Code LOB code
	Code *string `json:"Code,omitempty"`

	// Name LOB name
	Name *string `json:"Name,omitempty"`
}

// LogNote defines model for LogNote.
type LogNote struct {
	// Channel Log action channel/type (LogAction enum)
	Channel LogNoteChannel `json:"Channel"`

	// Note The log note content
	Note string `json:"Note"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`
	Task     *TaskAssignment     `json:"Task,omitempty"`
}

// LogNoteChannel Log action channel/type (LogAction enum)
type LogNoteChannel string

// Office defines model for Office.
type Office struct {
	// AddressLine1 Street address line 1
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Street address line 2
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// City City
	City *string `json:"City,omitempty"`

	// OfficeDescription Office description or name
	OfficeDescription *string `json:"OfficeDescription,omitempty"`

	// OfficeId Unique office identifier
	OfficeId *int `json:"OfficeId,omitempty"`

	// PrimaryOffice Whether this is the primary office
	PrimaryOffice *bool `json:"PrimaryOffice,omitempty"`

	// State State or province
	State *string `json:"State,omitempty"`

	// SubAgencyName Sub-agency name
	SubAgencyName *string `json:"SubAgencyName,omitempty"`

	// Zipcode ZIP or postal code
	Zipcode *string `json:"Zipcode,omitempty"`
}

// Person defines model for Person.
type Person struct {
	// DateOfBirth Date of birth in format 2024-10-08T00:00:00 (optional)
	DateOfBirth *string `json:"DateOfBirth,omitempty"`

	// FirstName First name (optional)
	FirstName *string `json:"FirstName,omitempty"`

	// Gender Gender enum (required)
	Gender string `json:"Gender"`

	// LastName Last name (optional)
	LastName *string `json:"LastName,omitempty"`

	// Occupation Occupation (optional)
	Occupation *string `json:"Occupation,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	// AccountNumber An agency created account number or other identifier
	AccountNumber *string `json:"AccountNumber,omitempty"`

	// AdditionalInterests Additional interest parties associated with the policy
	AdditionalInterests []map[string]interface{} `json:"AdditionalInterests"`

	// Agent1 Policy level agent field for tracking writing and commission amounts
	Agent1 *string `json:"Agent1,omitempty"`

	// Agent2 Policy level agent field for tracking writing and commission amounts
	Agent2 *string `json:"Agent2,omitempty"`

	// Agent3 Policy level agent field for tracking writing and commission amounts
	Agent3 *string `json:"Agent3,omitempty"`

	// AgentCode Agent code assigned by the carrier
	AgentCode *string `json:"AgentCode,omitempty"`

	// ApplicationType Application type, e.g. "Personal", "Commercial", "Agriculture"
	ApplicationType string `json:"ApplicationType"`

	// Autos Auto vehicles associated with the policy
	Autos []map[string]interface{} `json:"Autos"`

	// BillingPlan Billing plan assigned to the policy
	BillingPlan *string `json:"BillingPlan,omitempty"`

	// BillingType Billing type, e.g. "Direct", "Agency Bill", "Premium Finance"
	BillingType string `json:"BillingType"`

	// BoatOperators Boat operators associated with the policy
	BoatOperators []map[string]interface{} `json:"BoatOperators"`

	// Boats Boat vehicles covered by the policy
	Boats []map[string]interface{} `json:"Boats"`

	// Carrier Insuring carrier or general agency for the policy
	Carrier string `json:"Carrier"`

	// Coverages Coverage records on the policy
	Coverages []map[string]interface{} `json:"Coverages"`

	// Drivers Drivers associated with the policy
	Drivers []map[string]interface{} `json:"Drivers"`

	// EffectiveDate Date the current policy term goes into effect
	EffectiveDate *string `json:"EffectiveDate,omitempty"`

	// ExpirationDate Date the current policy term expires
	ExpirationDate *string `json:"ExpirationDate,omitempty"`

	// Id Unique policy identifier
	Id openapi_types.UUID `json:"Id"`

	// InceptionDate Date the policy was originally written
	InceptionDate *string `json:"InceptionDate,omitempty"`

	// LOBs Lines of business associated with the policy
	LOBs []LOB `json:"LOBs"`

	// LegacyId Legacy policy identifier
	LegacyId *int32 `json:"LegacyId,omitempty"`

	// LocationReferences Location references associated with the policy
	LocationReferences []map[string]interface{} `json:"LocationReferences"`

	// Locations Locations tied to the policy
	Locations []map[string]interface{} `json:"Locations"`

	// Modified Last modified timestamp for the policy
	Modified time.Time `json:"Modified"`

	// NAIC NAIC number assigned to the underwriting company
	NAIC *string `json:"NAIC,omitempty"`

	// NonCommissionable Non-commissionable amount on the policy
	NonCommissionable *float64 `json:"NonCommissionable,omitempty"`

	// Note Agency notes recorded for the policy
	Note *string `json:"Note,omitempty"`

	// NumberOfTerms Number of terms the policy has had
	NumberOfTerms int32 `json:"NumberOfTerms"`

	// OfficeId Identifier for the agency office assigned to the policy
	OfficeId int32 `json:"OfficeId"`

	// PaymentPlan Payment plan applied to the policy, e.g. "Monthly" or "Annual"
	PaymentPlan string `json:"PaymentPlan"`

	// PolicyIndex Position on the client file where the policy appears; the first policy entered has an index of 0 and subsequent policies increment from there
	PolicyIndex int32 `json:"PolicyIndex"`

	// PolicyNumber Policy number assigned by the carrier
	PolicyNumber *string `json:"PolicyNumber,omitempty"`

	// PolicyState State in which the policy is written
	PolicyState string `json:"PolicyState"`

	// Premium Policy premium amount
	Premium *float64 `json:"Premium,omitempty"`

	// PremiumMode Premium mode; when set to "Annualize" the premium reflects a 12-month equivalent regardless of term length
	PremiumMode string `json:"PremiumMode"`

	// Program Policy program or underwriting tier
	Program string `json:"Program"`

	// QuotedPremium Quoted premium prior to issue
	QuotedPremium *float64 `json:"QuotedPremium,omitempty"`

	// RaterCode Rater code associated with the policy record
	RaterCode int32 `json:"RaterCode"`

	// SoldDate Original sold date for the policy
	SoldDate *string `json:"SoldDate,omitempty"`

	// Source Source of the policy as configured by the agency
	Source *string `json:"Source,omitempty"`

	// Status Current status of the policy
	Status string `json:"Status"`

	// StatusDate Effective date of the current status
	StatusDate string `json:"StatusDate"`

	// SubStatus Current sub-status of the policy
	SubStatus *string `json:"SubStatus,omitempty"`

	// Term Policy term descriptor
	Term string `json:"Term"`

	// Title Policy title, e.g. "AUTOP", "PKGE", "CPKGE"
	Title string `json:"Title"`

	// Type Policy type, e.g. "Auto", "Home", "General"
	Type string `json:"Type"`

	// WritingCarrier Writing carrier associated with the policy
	WritingCarrier *string `json:"WritingCarrier,omitempty"`
}

// Receipt defines model for Receipt.
type Receipt struct {
	// Channel Source of interaction (LogAction enum, required)
	Channel ReceiptChannel `json:"Channel"`

	// Invoices Invoices being paid (required)
	Invoices []ReceiptInvoiceItem `json:"Invoices"`

	// LogNote Payment log note (optional)
	LogNote *string `json:"LogNote,omitempty"`

	// OfficeId Payment's office ID (optional)
	OfficeId *int `json:"OfficeId,omitempty"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`

	// RefId Unique ID for the receipt (required)
	RefId openapi_types.UUID `json:"RefId"`

	// TS Payment received timestamp (required)
	TS   time.Time       `json:"TS"`
	Task *TaskAssignment `json:"Task,omitempty"`

	// Total Total payment amount
	Total *float64 `json:"Total,omitempty"`
}

// ReceiptChannel Source of interaction (LogAction enum, required)
type ReceiptChannel string

// ReceiptInvoiceItem defines model for ReceiptInvoiceItem.
type ReceiptInvoiceItem struct {
	// Amount Amount being paid towards this invoice (required)
	Amount float64 `json:"Amount"`

	// InvoiceId Invoice GUID (required)
	InvoiceId openapi_types.UUID `json:"InvoiceId"`
}

// TaskAssignment defines model for TaskAssignment.
type TaskAssignment struct {
	// AssignedToEmail Email address (required if AssignedToRole is SpecifiedUser)
	AssignedToEmail *openapi_types.Email `json:"AssignedToEmail,omitempty"`

	// AssignedToRole Role to assign task to
	AssignedToRole *TaskAssignmentAssignedToRole `json:"AssignedToRole,omitempty"`

	// Description Task description
	Description *string `json:"Description,omitempty"`

	// DueDate Task due date
	DueDate *time.Time `json:"DueDate,omitempty"`

	// Title Task title
	Title *string `json:"Title,omitempty"`
}

// TaskAssignmentAssignedToRole Role to assign task to
type TaskAssignmentAssignedToRole string

// AgencyIdParam defines model for AgencyIdParam.
type AgencyIdParam = string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// ClientIncludesParam defines model for ClientIncludesParam.
type ClientIncludesParam = []string

// VersionParam defines model for VersionParam.
type VersionParam string

// NotFoundError defines model for NotFoundError.
type NotFoundError = Error

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError = Error

// GetAgenciesParams defines parameters for GetAgencies.
type GetAgenciesParams struct {
	// Version API version (must be 3.0)
	Version GetAgenciesParamsVersion `form:"version" json:"version"`
}

// GetAgenciesParamsVersion defines parameters for GetAgencies.
type GetAgenciesParamsVersion string

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Version API version (must be 3.0)
	Version GetClientParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`
}

// GetClientParamsVersion defines parameters for GetClient.
type GetClientParamsVersion string

// GetClientParamsInclude defines parameters for GetClient.
type GetClientParamsInclude string

// UploadAttachmentMultipartBody defines parameters for UploadAttachment.
type UploadAttachmentMultipartBody struct {
	// File The file to upload
	File openapi_types.File `json:"file"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// Version API version (must be 3.0)
	Version UploadAttachmentParamsVersion `form:"version" json:"version"`

	// RefId Reference ID for the attachment
	RefId string `json:"RefId"`

	// Timestamp Timestamp of the attachment
	Timestamp time.Time `json:"Timestamp"`

	// Filename Name of the file being uploaded
	Filename string `json:"Filename"`

	// FileExtension File extension
	FileExtension string `json:"FileExtension"`

	// AssignTask Whether to assign this as a task
	AssignTask *bool `json:"AssignTask,omitempty"`

	// AssignedTo User to assign task to
	AssignedTo *string `json:"AssignedTo,omitempty"`

	// DueDate Task due date if assigned
	DueDate *time.Time `json:"DueDate,omitempty"`
}

// UploadAttachmentParamsVersion defines parameters for UploadAttachment.
type UploadAttachmentParamsVersion string

// CreateLogNoteParams defines parameters for CreateLogNote.
type CreateLogNoteParams struct {
	// Version API version (must be 3.0)
	Version CreateLogNoteParamsVersion `form:"version" json:"version"`
}

// CreateLogNoteParamsVersion defines parameters for CreateLogNote.
type CreateLogNoteParamsVersion string

// CreateReceiptsJSONBody defines parameters for CreateReceipts.
type CreateReceiptsJSONBody = []Receipt

// CreateReceiptsParams defines parameters for CreateReceipts.
type CreateReceiptsParams struct {
	// Version API version (must be 3.0)
	Version CreateReceiptsParamsVersion `form:"version" json:"version"`
}

// CreateReceiptsParamsVersion defines parameters for CreateReceipts.
type CreateReceiptsParamsVersion string

// GetChangedClientsParams defines parameters for GetChangedClients.
type GetChangedClientsParams struct {
	// Version API version (must be 3.0)
	Version GetChangedClientsParamsVersion `form:"version" json:"version"`

	// AsOf Return clients changed since this datetime (optional)
	AsOf *time.Time `form:"asOf,omitempty" json:"asOf,omitempty"`

	// OfficeId Filter changes by specific office (optional)
	OfficeId *int `form:"officeId,omitempty" json:"officeId,omitempty"`

	// Deleted Include deleted clients
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`
}

// GetChangedClientsParamsVersion defines parameters for GetChangedClients.
type GetChangedClientsParamsVersion string

// GetClientListJSONBody defines parameters for GetClientList.
type GetClientListJSONBody struct {
	// ClientNumbers Array of client numbers to retrieve
	ClientNumbers *[]string `json:"clientNumbers,omitempty"`
}

// GetClientListParams defines parameters for GetClientList.
type GetClientListParams struct {
	// Version API version (must be 3.0)
	Version GetClientListParamsVersion `form:"version" json:"version"`
}

// GetClientListParamsVersion defines parameters for GetClientList.
type GetClientListParamsVersion string

// SearchClientsParams defines parameters for SearchClients.
type SearchClientsParams struct {
	// Version API version (must be 3.0)
	Version SearchClientsParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`

	// PolicyNumber Exact policy number to search for
	PolicyNumber *string `form:"policyNumber,omitempty" json:"policyNumber,omitempty"`
}

// SearchClientsParamsVersion defines parameters for SearchClients.
type SearchClientsParamsVersion string

// SearchClientsParamsInclude defines parameters for SearchClients.
type SearchClientsParamsInclude string

// GetAgencyOfficesParams defines parameters for GetAgencyOffices.
type GetAgencyOfficesParams struct {
	// Version API version (must be 3.0)
	Version GetAgencyOfficesParamsVersion `form:"version" json:"version"`
}

// GetAgencyOfficesParamsVersion defines parameters for GetAgencyOffices.
type GetAgencyOfficesParamsVersion string

// UploadAttachmentMultipartRequestBody defines body for UploadAttachment for multipart/form-data ContentType.
type UploadAttachmentMultipartRequestBody UploadAttachmentMultipartBody

// CreateLogNoteJSONRequestBody defines body for CreateLogNote for application/json ContentType.
type CreateLogNoteJSONRequestBody = LogNote

// CreateReceiptsJSONRequestBody defines body for CreateReceipts for application/json ContentType.
type CreateReceiptsJSONRequestBody = CreateReceiptsJSONBody

// GetClientListJSONRequestBody defines body for GetClientList for application/json ContentType.
type GetClientListJSONRequestBody GetClientListJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAgencies request
	GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAttachmentWithBody request with any body
	UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogNoteWithBody request with any body
	CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReceiptsWithBody request with any body
	CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChangedClients request
	GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientListWithBody request with any body
	GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClients request
	SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgencyOffices request
	GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, agencyId, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAttachmentRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangedClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequestWithBody(c.Server, agencyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequest(c.Server, agencyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgencyOfficesRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAgenciesRequest generates requests for GetAgencies
func NewGetAgenciesRequest(server string, params *GetAgenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadAttachmentRequestWithBody generates requests for UploadAttachment with any type of body
func NewUploadAttachmentRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/attachment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "RefId", runtime.ParamLocationHeader, params.RefId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("RefId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Timestamp", runtime.ParamLocationHeader, params.Timestamp)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Timestamp", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Filename", runtime.ParamLocationHeader, params.Filename)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Filename", headerParam2)

		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "FileExtension", runtime.ParamLocationHeader, params.FileExtension)
		if err != nil {
			return nil, err
		}

		req.Header.Set("FileExtension", headerParam3)

		if params.AssignTask != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "AssignTask", runtime.ParamLocationHeader, *params.AssignTask)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignTask", headerParam4)
		}

		if params.AssignedTo != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "AssignedTo", runtime.ParamLocationHeader, *params.AssignedTo)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignedTo", headerParam5)
		}

		if params.DueDate != nil {
			var headerParam6 string

			headerParam6, err = runtime.StyleParamWithLocation("simple", false, "DueDate", runtime.ParamLocationHeader, *params.DueDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("DueDate", headerParam6)
		}

	}

	return req, nil
}

// NewCreateLogNoteRequest calls the generic CreateLogNote builder with application/json body
func NewCreateLogNoteRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogNoteRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateLogNoteRequestWithBody generates requests for CreateLogNote with any type of body
func NewCreateLogNoteRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/log", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateReceiptsRequest calls the generic CreateReceipts builder with application/json body
func NewCreateReceiptsRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReceiptsRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateReceiptsRequestWithBody generates requests for CreateReceipts with any type of body
func NewCreateReceiptsRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/receipts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChangedClientsRequest generates requests for GetChangedClients
func NewGetChangedClientsRequest(server string, agencyId AgencyIdParam, params *GetChangedClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AsOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asOf", runtime.ParamLocationQuery, *params.AsOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officeId", runtime.ParamLocationQuery, *params.OfficeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientListRequest calls the generic GetClientList builder with application/json body
func NewGetClientListRequest(server string, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetClientListRequestWithBody(server, agencyId, params, "application/json", bodyReader)
}

// NewGetClientListRequestWithBody generates requests for GetClientList with any type of body
func NewGetClientListRequestWithBody(server string, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsRequest generates requests for SearchClients
func NewSearchClientsRequest(server string, agencyId AgencyIdParam, params *SearchClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyNumber", runtime.ParamLocationQuery, *params.PolicyNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgencyOfficesRequest generates requests for GetAgencyOffices
func NewGetAgencyOfficesRequest(server string, agencyId AgencyIdParam, params *GetAgencyOfficesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/offices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAgenciesWithResponse request
	GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UploadAttachmentWithBodyWithResponse request with any body
	UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error)

	// CreateLogNoteWithBodyWithResponse request with any body
	CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	// CreateReceiptsWithBodyWithResponse request with any body
	CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	// GetChangedClientsWithResponse request
	GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error)

	// GetClientListWithBodyWithResponse request with any body
	GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	// SearchClientsWithResponse request
	SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error)

	// GetAgencyOfficesWithResponse request
	GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error)
}

type GetAgenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agency
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetAgenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UploadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateLogNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReceiptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateReceiptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReceiptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangedClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]int32
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetChangedClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangedClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientData
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r SearchClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgencyOfficesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Office
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAgencyOfficesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgencyOfficesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAgenciesWithResponse request returning *GetAgenciesResponse
func (c *ClientWithResponses) GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error) {
	rsp, err := c.GetAgencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgenciesResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, agencyId, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UploadAttachmentWithBodyWithResponse request with arbitrary body returning *UploadAttachmentResponse
func (c *ClientWithResponses) UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error) {
	rsp, err := c.UploadAttachmentWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAttachmentResponse(rsp)
}

// CreateLogNoteWithBodyWithResponse request with arbitrary body returning *CreateLogNoteResponse
func (c *ClientWithResponses) CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNoteWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

func (c *ClientWithResponses) CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNote(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

// CreateReceiptsWithBodyWithResponse request with arbitrary body returning *CreateReceiptsResponse
func (c *ClientWithResponses) CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceiptsWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

func (c *ClientWithResponses) CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceipts(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

// GetChangedClientsWithResponse request returning *GetChangedClientsResponse
func (c *ClientWithResponses) GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error) {
	rsp, err := c.GetChangedClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangedClientsResponse(rsp)
}

// GetClientListWithBodyWithResponse request with arbitrary body returning *GetClientListResponse
func (c *ClientWithResponses) GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientListWithBody(ctx, agencyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

func (c *ClientWithResponses) GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientList(ctx, agencyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

// SearchClientsWithResponse request returning *SearchClientsResponse
func (c *ClientWithResponses) SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error) {
	rsp, err := c.SearchClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsResponse(rsp)
}

// GetAgencyOfficesWithResponse request returning *GetAgencyOfficesResponse
func (c *ClientWithResponses) GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error) {
	rsp, err := c.GetAgencyOffices(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgencyOfficesResponse(rsp)
}

// ParseGetAgenciesResponse parses an HTTP response from a GetAgenciesWithResponse call
func ParseGetAgenciesResponse(rsp *http.Response) (*GetAgenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadAttachmentResponse parses an HTTP response from a UploadAttachmentWithResponse call
func ParseUploadAttachmentResponse(rsp *http.Response) (*UploadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateLogNoteResponse parses an HTTP response from a CreateLogNoteWithResponse call
func ParseCreateLogNoteResponse(rsp *http.Response) (*CreateLogNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReceiptsResponse parses an HTTP response from a CreateReceiptsWithResponse call
func ParseCreateReceiptsResponse(rsp *http.Response) (*CreateReceiptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReceiptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChangedClientsResponse parses an HTTP response from a GetChangedClientsWithResponse call
func ParseGetChangedClientsResponse(rsp *http.Response) (*GetChangedClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangedClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClientListResponse parses an HTTP response from a GetClientListWithResponse call
func ParseGetClientListResponse(rsp *http.Response) (*GetClientListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchClientsResponse parses an HTTP response from a SearchClientsWithResponse call
func ParseSearchClientsResponse(rsp *http.Response) (*SearchClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAgencyOfficesResponse parses an HTTP response from a GetAgencyOfficesWithResponse call
func ParseGetAgencyOfficesResponse(rsp *http.Response) (*GetAgencyOfficesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgencyOfficesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Office
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
