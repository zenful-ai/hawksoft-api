// Package hawksoft provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package hawksoft

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for LogNoteChannel.
const (
	LogNoteChannelEmail    LogNoteChannel = "Email"
	LogNoteChannelFax      LogNoteChannel = "Fax"
	LogNoteChannelInPerson LogNoteChannel = "InPerson"
	LogNoteChannelMail     LogNoteChannel = "Mail"
	LogNoteChannelOther    LogNoteChannel = "Other"
	LogNoteChannelPhone    LogNoteChannel = "Phone"
)

// Defines values for ReceiptChannel.
const (
	ReceiptChannelEmail    ReceiptChannel = "Email"
	ReceiptChannelFax      ReceiptChannel = "Fax"
	ReceiptChannelInPerson ReceiptChannel = "InPerson"
	ReceiptChannelMail     ReceiptChannel = "Mail"
	ReceiptChannelOther    ReceiptChannel = "Other"
	ReceiptChannelPhone    ReceiptChannel = "Phone"
)

// Defines values for TaskAssignmentAssignedToRole.
const (
	AccountManager TaskAssignmentAssignedToRole = "AccountManager"
	CSR            TaskAssignmentAssignedToRole = "CSR"
	Producer       TaskAssignmentAssignedToRole = "Producer"
	SpecifiedUser  TaskAssignmentAssignedToRole = "SpecifiedUser"
	Underwriter    TaskAssignmentAssignedToRole = "Underwriter"
)

// Defines values for VersionParam.
const (
	VersionParamN30 VersionParam = "3.0"
)

// Defines values for GetAgenciesParamsVersion.
const (
	GetAgenciesParamsVersionN30 GetAgenciesParamsVersion = "3.0"
)

// Defines values for GetClientParamsVersion.
const (
	GetClientParamsVersionN30 GetClientParamsVersion = "3.0"
)

// Defines values for GetClientParamsInclude.
const (
	GetClientParamsIncludeClaims   GetClientParamsInclude = "Claims"
	GetClientParamsIncludeContacts GetClientParamsInclude = "Contacts"
	GetClientParamsIncludeDetails  GetClientParamsInclude = "Details"
	GetClientParamsIncludeInvoices GetClientParamsInclude = "Invoices"
	GetClientParamsIncludePeople   GetClientParamsInclude = "People"
	GetClientParamsIncludePolicies GetClientParamsInclude = "Policies"
)

// Defines values for UploadAttachmentParamsVersion.
const (
	UploadAttachmentParamsVersionN30 UploadAttachmentParamsVersion = "3.0"
)

// Defines values for CreateLogNoteParamsVersion.
const (
	CreateLogNoteParamsVersionN30 CreateLogNoteParamsVersion = "3.0"
)

// Defines values for CreateReceiptsParamsVersion.
const (
	CreateReceiptsParamsVersionN30 CreateReceiptsParamsVersion = "3.0"
)

// Defines values for GetChangedClientsParamsVersion.
const (
	GetChangedClientsParamsVersionN30 GetChangedClientsParamsVersion = "3.0"
)

// Defines values for GetClientListParamsVersion.
const (
	GetClientListParamsVersionN30 GetClientListParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsVersion.
const (
	SearchClientsParamsVersionN30 SearchClientsParamsVersion = "3.0"
)

// Defines values for SearchClientsParamsInclude.
const (
	SearchClientsParamsIncludeClaims   SearchClientsParamsInclude = "Claims"
	SearchClientsParamsIncludeContacts SearchClientsParamsInclude = "Contacts"
	SearchClientsParamsIncludeDetails  SearchClientsParamsInclude = "Details"
	SearchClientsParamsIncludeInvoices SearchClientsParamsInclude = "Invoices"
	SearchClientsParamsIncludePeople   SearchClientsParamsInclude = "People"
	SearchClientsParamsIncludePolicies SearchClientsParamsInclude = "Policies"
)

// Defines values for GetAgencyOfficesParamsVersion.
const (
	GetAgencyOfficesParamsVersionN30 GetAgencyOfficesParamsVersion = "3.0"
)

// Agency Agency ID
type Agency = int

// Claim defines model for Claim.
type Claim struct {
	// ClaimNumber Claim number (optional)
	ClaimNumber *string `json:"ClaimNumber,omitempty"`

	// ClaimStatus Claim status enum (required)
	ClaimStatus string `json:"ClaimStatus"`

	// LossAmount Loss amount (optional)
	LossAmount *float64 `json:"LossAmount,omitempty"`

	// LossDate Loss date in format 2024-10-08T00:00:00 (optional)
	LossDate *string `json:"LossDate,omitempty"`

	// PolicyNumber Associated policy number (optional)
	PolicyNumber *string `json:"PolicyNumber,omitempty"`
}

// ClientData Complete client information with optional includes
type ClientData struct {
	// Claims Claims associated with the client (required)
	Claims []Claim `json:"Claims"`

	// ClientNumber Client number (required)
	ClientNumber int32 `json:"ClientNumber"`

	// Contacts Contact information (required)
	Contacts []Contact     `json:"Contacts"`
	Details  ClientDetails `json:"Details"`

	// Invoices Invoices (optional, requires include parameter)
	Invoices *[]Invoice `json:"Invoices,omitempty"`

	// People People associated with the client (required)
	People []Person `json:"People"`

	// Policies Policies associated with the client (required)
	Policies []Policy `json:"Policies"`
}

// ClientDetails defines model for ClientDetails.
type ClientDetails struct {
	// AgencyNum Agency number (optional)
	AgencyNum *string `json:"AgencyNum,omitempty"`

	// BusinessType Business type enum (optional)
	BusinessType *string `json:"BusinessType,omitempty"`

	// ClientType Client type enum (required)
	ClientType string `json:"ClientType"`

	// CompanyName Company name for commercial clients (optional)
	CompanyName *string `json:"CompanyName,omitempty"`

	// IsCommercial Whether this is a commercial client (required)
	IsCommercial bool `json:"IsCommercial"`

	// IsPersonal Whether this is a personal client (required)
	IsPersonal bool `json:"IsPersonal"`

	// Status Client status enum (required)
	Status string `json:"Status"`
}

// Contact defines model for Contact.
type Contact struct {
	// Data Contact data (phone, email, etc.) (required)
	Data string `json:"Data"`

	// IsBillingContact Whether this is a billing contact (required)
	IsBillingContact bool `json:"IsBillingContact"`

	// PersonId GUID of associated person (optional)
	PersonId *openapi_types.UUID `json:"PersonId,omitempty"`

	// Type Contact type enum (required)
	Type string `json:"Type"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code *string `json:"code,omitempty"`

	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	// Balance Invoice balance (required)
	Balance float64 `json:"Balance"`

	// Date Invoice date (required)
	Date openapi_types.Date `json:"Date"`

	// DueDate Invoice due date (required)
	DueDate openapi_types.Date `json:"DueDate"`

	// InvoiceNumber Invoice number (required)
	InvoiceNumber string `json:"InvoiceNumber"`

	// Total Invoice total amount (required)
	Total float64 `json:"Total"`
}

// LOB Line of Business
type LOB struct {
	// Code LOB code
	Code *string `json:"Code,omitempty"`

	// Name LOB name
	Name *string `json:"Name,omitempty"`
}

// LogNote defines model for LogNote.
type LogNote struct {
	// Channel Log action channel/type (LogAction enum)
	Channel LogNoteChannel `json:"Channel"`

	// Note The log note content
	Note string `json:"Note"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`
	Task     *TaskAssignment     `json:"Task,omitempty"`
}

// LogNoteChannel Log action channel/type (LogAction enum)
type LogNoteChannel string

// Office defines model for Office.
type Office struct {
	// AddressLine1 Street address line 1
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Street address line 2
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// City City
	City *string `json:"City,omitempty"`

	// OfficeDescription Office description or name
	OfficeDescription *string `json:"OfficeDescription,omitempty"`

	// OfficeId Unique office identifier
	OfficeId *int `json:"OfficeId,omitempty"`

	// PrimaryOffice Whether this is the primary office
	PrimaryOffice *bool `json:"PrimaryOffice,omitempty"`

	// State State or province
	State *string `json:"State,omitempty"`

	// SubAgencyName Sub-agency name
	SubAgencyName *string `json:"SubAgencyName,omitempty"`

	// Zipcode ZIP or postal code
	Zipcode *string `json:"Zipcode,omitempty"`
}

// Person defines model for Person.
type Person struct {
	// DateOfBirth Date of birth in format 2024-10-08T00:00:00 (optional)
	DateOfBirth *string `json:"DateOfBirth,omitempty"`

	// FirstName First name (optional)
	FirstName *string `json:"FirstName,omitempty"`

	// Gender Gender enum (required)
	Gender string `json:"Gender"`

	// LastName Last name (optional)
	LastName *string `json:"LastName,omitempty"`

	// Occupation Occupation (optional)
	Occupation *string `json:"Occupation,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	// AccountNumber Account number (optional)
	AccountNumber *string `json:"AccountNumber,omitempty"`

	// Carrier Insurance carrier (required)
	Carrier string `json:"Carrier"`

	// EffectiveDate Policy effective date in format 2024-10-08T00:00:00 (optional)
	EffectiveDate *string `json:"EffectiveDate,omitempty"`

	// ExpirationDate Policy expiration date in format 2024-10-08T00:00:00 (optional)
	ExpirationDate *string `json:"ExpirationDate,omitempty"`

	// LOBs Lines of business (required)
	LOBs []LOB `json:"LOBs"`

	// PolicyNumber Policy number (optional)
	PolicyNumber *string `json:"PolicyNumber,omitempty"`

	// Premium Policy premium amount (optional)
	Premium *float64 `json:"Premium,omitempty"`

	// Status Policy status enum (required)
	Status string `json:"Status"`

	// Type Policy type enum (required)
	Type string `json:"Type"`
}

// Receipt defines model for Receipt.
type Receipt struct {
	// Channel Source of interaction (LogAction enum, required)
	Channel ReceiptChannel `json:"Channel"`

	// Invoices Invoices being paid (required)
	Invoices []ReceiptInvoiceItem `json:"Invoices"`

	// LogNote Payment log note (optional)
	LogNote *string `json:"LogNote,omitempty"`

	// OfficeId Payment's office ID (optional)
	OfficeId *int `json:"OfficeId,omitempty"`

	// PolicyId Optional GUID of associated policy
	PolicyId *openapi_types.UUID `json:"PolicyId,omitempty"`

	// RefId Unique ID for the receipt (required)
	RefId openapi_types.UUID `json:"RefId"`

	// TS Payment received timestamp (required)
	TS   time.Time       `json:"TS"`
	Task *TaskAssignment `json:"Task,omitempty"`

	// Total Total payment amount
	Total *float64 `json:"Total,omitempty"`
}

// ReceiptChannel Source of interaction (LogAction enum, required)
type ReceiptChannel string

// ReceiptInvoiceItem defines model for ReceiptInvoiceItem.
type ReceiptInvoiceItem struct {
	// Amount Amount being paid towards this invoice (required)
	Amount float64 `json:"Amount"`

	// InvoiceId Invoice GUID (required)
	InvoiceId openapi_types.UUID `json:"InvoiceId"`
}

// TaskAssignment defines model for TaskAssignment.
type TaskAssignment struct {
	// AssignedToEmail Email address (required if AssignedToRole is SpecifiedUser)
	AssignedToEmail *openapi_types.Email `json:"AssignedToEmail,omitempty"`

	// AssignedToRole Role to assign task to
	AssignedToRole *TaskAssignmentAssignedToRole `json:"AssignedToRole,omitempty"`

	// Description Task description
	Description *string `json:"Description,omitempty"`

	// DueDate Task due date
	DueDate *time.Time `json:"DueDate,omitempty"`

	// Title Task title
	Title *string `json:"Title,omitempty"`
}

// TaskAssignmentAssignedToRole Role to assign task to
type TaskAssignmentAssignedToRole string

// AgencyIdParam defines model for AgencyIdParam.
type AgencyIdParam = string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// ClientIncludesParam defines model for ClientIncludesParam.
type ClientIncludesParam = []string

// VersionParam defines model for VersionParam.
type VersionParam string

// NotFoundError defines model for NotFoundError.
type NotFoundError = Error

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError = Error

// GetAgenciesParams defines parameters for GetAgencies.
type GetAgenciesParams struct {
	// Version API version (must be 3.0)
	Version GetAgenciesParamsVersion `form:"version" json:"version"`
}

// GetAgenciesParamsVersion defines parameters for GetAgencies.
type GetAgenciesParamsVersion string

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Version API version (must be 3.0)
	Version GetClientParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`
}

// GetClientParamsVersion defines parameters for GetClient.
type GetClientParamsVersion string

// GetClientParamsInclude defines parameters for GetClient.
type GetClientParamsInclude string

// UploadAttachmentMultipartBody defines parameters for UploadAttachment.
type UploadAttachmentMultipartBody struct {
	// File The file to upload
	File openapi_types.File `json:"file"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// Version API version (must be 3.0)
	Version UploadAttachmentParamsVersion `form:"version" json:"version"`

	// RefId Reference ID for the attachment
	RefId string `json:"RefId"`

	// Timestamp Timestamp of the attachment
	Timestamp time.Time `json:"Timestamp"`

	// Filename Name of the file being uploaded
	Filename string `json:"Filename"`

	// FileExtension File extension
	FileExtension string `json:"FileExtension"`

	// AssignTask Whether to assign this as a task
	AssignTask *bool `json:"AssignTask,omitempty"`

	// AssignedTo User to assign task to
	AssignedTo *string `json:"AssignedTo,omitempty"`

	// DueDate Task due date if assigned
	DueDate *time.Time `json:"DueDate,omitempty"`
}

// UploadAttachmentParamsVersion defines parameters for UploadAttachment.
type UploadAttachmentParamsVersion string

// CreateLogNoteParams defines parameters for CreateLogNote.
type CreateLogNoteParams struct {
	// Version API version (must be 3.0)
	Version CreateLogNoteParamsVersion `form:"version" json:"version"`
}

// CreateLogNoteParamsVersion defines parameters for CreateLogNote.
type CreateLogNoteParamsVersion string

// CreateReceiptsJSONBody defines parameters for CreateReceipts.
type CreateReceiptsJSONBody = []Receipt

// CreateReceiptsParams defines parameters for CreateReceipts.
type CreateReceiptsParams struct {
	// Version API version (must be 3.0)
	Version CreateReceiptsParamsVersion `form:"version" json:"version"`
}

// CreateReceiptsParamsVersion defines parameters for CreateReceipts.
type CreateReceiptsParamsVersion string

// GetChangedClientsParams defines parameters for GetChangedClients.
type GetChangedClientsParams struct {
	// Version API version (must be 3.0)
	Version GetChangedClientsParamsVersion `form:"version" json:"version"`

	// AsOf Return clients changed since this datetime (optional)
	AsOf *time.Time `form:"asOf,omitempty" json:"asOf,omitempty"`

	// OfficeId Filter changes by specific office (optional)
	OfficeId *int `form:"officeId,omitempty" json:"officeId,omitempty"`

	// Deleted Include deleted clients
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`
}

// GetChangedClientsParamsVersion defines parameters for GetChangedClients.
type GetChangedClientsParamsVersion string

// GetClientListJSONBody defines parameters for GetClientList.
type GetClientListJSONBody struct {
	// ClientNumbers Array of client numbers to retrieve
	ClientNumbers *[]string `json:"clientNumbers,omitempty"`
}

// GetClientListParams defines parameters for GetClientList.
type GetClientListParams struct {
	// Version API version (must be 3.0)
	Version GetClientListParamsVersion `form:"version" json:"version"`
}

// GetClientListParamsVersion defines parameters for GetClientList.
type GetClientListParamsVersion string

// SearchClientsParams defines parameters for SearchClients.
type SearchClientsParams struct {
	// Version API version (must be 3.0)
	Version SearchClientsParamsVersion `form:"version" json:"version"`

	// Include Optional client includes to retrieve additional data
	Include *ClientIncludesParam `form:"include,omitempty" json:"include,omitempty"`

	// PolicyNumber Exact policy number to search for
	PolicyNumber *string `form:"policyNumber,omitempty" json:"policyNumber,omitempty"`
}

// SearchClientsParamsVersion defines parameters for SearchClients.
type SearchClientsParamsVersion string

// SearchClientsParamsInclude defines parameters for SearchClients.
type SearchClientsParamsInclude string

// GetAgencyOfficesParams defines parameters for GetAgencyOffices.
type GetAgencyOfficesParams struct {
	// Version API version (must be 3.0)
	Version GetAgencyOfficesParamsVersion `form:"version" json:"version"`
}

// GetAgencyOfficesParamsVersion defines parameters for GetAgencyOffices.
type GetAgencyOfficesParamsVersion string

// UploadAttachmentMultipartRequestBody defines body for UploadAttachment for multipart/form-data ContentType.
type UploadAttachmentMultipartRequestBody UploadAttachmentMultipartBody

// CreateLogNoteJSONRequestBody defines body for CreateLogNote for application/json ContentType.
type CreateLogNoteJSONRequestBody = LogNote

// CreateReceiptsJSONRequestBody defines body for CreateReceipts for application/json ContentType.
type CreateReceiptsJSONRequestBody = CreateReceiptsJSONBody

// GetClientListJSONRequestBody defines body for GetClientList for application/json ContentType.
type GetClientListJSONRequestBody GetClientListJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAgencies request
	GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAttachmentWithBody request with any body
	UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogNoteWithBody request with any body
	CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReceiptsWithBody request with any body
	CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChangedClients request
	GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientListWithBody request with any body
	GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClients request
	SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgencyOffices request
	GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAgencies(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, agencyId, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAttachmentWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAttachmentRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNoteWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogNote(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogNoteRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceiptsWithBody(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequestWithBody(c.Server, agencyId, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceipts(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptsRequest(c.Server, agencyId, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChangedClients(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangedClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientListWithBody(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequestWithBody(c.Server, agencyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientList(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientListRequest(c.Server, agencyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClients(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgencyOffices(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgencyOfficesRequest(c.Server, agencyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAgenciesRequest generates requests for GetAgencies
func NewGetAgenciesRequest(server string, params *GetAgenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadAttachmentRequestWithBody generates requests for UploadAttachment with any type of body
func NewUploadAttachmentRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/attachment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "RefId", runtime.ParamLocationHeader, params.RefId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("RefId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Timestamp", runtime.ParamLocationHeader, params.Timestamp)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Timestamp", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Filename", runtime.ParamLocationHeader, params.Filename)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Filename", headerParam2)

		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "FileExtension", runtime.ParamLocationHeader, params.FileExtension)
		if err != nil {
			return nil, err
		}

		req.Header.Set("FileExtension", headerParam3)

		if params.AssignTask != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "AssignTask", runtime.ParamLocationHeader, *params.AssignTask)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignTask", headerParam4)
		}

		if params.AssignedTo != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "AssignedTo", runtime.ParamLocationHeader, *params.AssignedTo)
			if err != nil {
				return nil, err
			}

			req.Header.Set("AssignedTo", headerParam5)
		}

		if params.DueDate != nil {
			var headerParam6 string

			headerParam6, err = runtime.StyleParamWithLocation("simple", false, "DueDate", runtime.ParamLocationHeader, *params.DueDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("DueDate", headerParam6)
		}

	}

	return req, nil
}

// NewCreateLogNoteRequest calls the generic CreateLogNote builder with application/json body
func NewCreateLogNoteRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogNoteRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateLogNoteRequestWithBody generates requests for CreateLogNote with any type of body
func NewCreateLogNoteRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/log", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateReceiptsRequest calls the generic CreateReceipts builder with application/json body
func NewCreateReceiptsRequest(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReceiptsRequestWithBody(server, agencyId, clientId, params, "application/json", bodyReader)
}

// NewCreateReceiptsRequestWithBody generates requests for CreateReceipts with any type of body
func NewCreateReceiptsRequestWithBody(server string, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/client/%s/receipts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChangedClientsRequest generates requests for GetChangedClients
func NewGetChangedClientsRequest(server string, agencyId AgencyIdParam, params *GetChangedClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AsOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asOf", runtime.ParamLocationQuery, *params.AsOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officeId", runtime.ParamLocationQuery, *params.OfficeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientListRequest calls the generic GetClientList builder with application/json body
func NewGetClientListRequest(server string, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetClientListRequestWithBody(server, agencyId, params, "application/json", bodyReader)
}

// NewGetClientListRequestWithBody generates requests for GetClientList with any type of body
func NewGetClientListRequestWithBody(server string, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsRequest generates requests for SearchClients
func NewSearchClientsRequest(server string, agencyId AgencyIdParam, params *SearchClientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyNumber", runtime.ParamLocationQuery, *params.PolicyNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgencyOfficesRequest generates requests for GetAgencyOffices
func NewGetAgencyOfficesRequest(server string, agencyId AgencyIdParam, params *GetAgencyOfficesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agencyId", runtime.ParamLocationPath, agencyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/agency/%s/offices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAgenciesWithResponse request
	GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UploadAttachmentWithBodyWithResponse request with any body
	UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error)

	// CreateLogNoteWithBodyWithResponse request with any body
	CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error)

	// CreateReceiptsWithBodyWithResponse request with any body
	CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error)

	// GetChangedClientsWithResponse request
	GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error)

	// GetClientListWithBodyWithResponse request with any body
	GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error)

	// SearchClientsWithResponse request
	SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error)

	// GetAgencyOfficesWithResponse request
	GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error)
}

type GetAgenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agency
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetAgenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UploadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateLogNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReceiptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CreateReceiptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReceiptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangedClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]int32
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetChangedClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangedClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientData
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetClientListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientData
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r SearchClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgencyOfficesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Office
	JSON401      *UnauthorizedError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAgencyOfficesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgencyOfficesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAgenciesWithResponse request returning *GetAgenciesResponse
func (c *ClientWithResponses) GetAgenciesWithResponse(ctx context.Context, params *GetAgenciesParams, reqEditors ...RequestEditorFn) (*GetAgenciesResponse, error) {
	rsp, err := c.GetAgencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgenciesResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, agencyId, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UploadAttachmentWithBodyWithResponse request with arbitrary body returning *UploadAttachmentResponse
func (c *ClientWithResponses) UploadAttachmentWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error) {
	rsp, err := c.UploadAttachmentWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAttachmentResponse(rsp)
}

// CreateLogNoteWithBodyWithResponse request with arbitrary body returning *CreateLogNoteResponse
func (c *ClientWithResponses) CreateLogNoteWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNoteWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

func (c *ClientWithResponses) CreateLogNoteWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateLogNoteParams, body CreateLogNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogNoteResponse, error) {
	rsp, err := c.CreateLogNote(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogNoteResponse(rsp)
}

// CreateReceiptsWithBodyWithResponse request with arbitrary body returning *CreateReceiptsResponse
func (c *ClientWithResponses) CreateReceiptsWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceiptsWithBody(ctx, agencyId, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

func (c *ClientWithResponses) CreateReceiptsWithResponse(ctx context.Context, agencyId AgencyIdParam, clientId ClientIdParam, params *CreateReceiptsParams, body CreateReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptsResponse, error) {
	rsp, err := c.CreateReceipts(ctx, agencyId, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptsResponse(rsp)
}

// GetChangedClientsWithResponse request returning *GetChangedClientsResponse
func (c *ClientWithResponses) GetChangedClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetChangedClientsParams, reqEditors ...RequestEditorFn) (*GetChangedClientsResponse, error) {
	rsp, err := c.GetChangedClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangedClientsResponse(rsp)
}

// GetClientListWithBodyWithResponse request with arbitrary body returning *GetClientListResponse
func (c *ClientWithResponses) GetClientListWithBodyWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientListWithBody(ctx, agencyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

func (c *ClientWithResponses) GetClientListWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetClientListParams, body GetClientListJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClientListResponse, error) {
	rsp, err := c.GetClientList(ctx, agencyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientListResponse(rsp)
}

// SearchClientsWithResponse request returning *SearchClientsResponse
func (c *ClientWithResponses) SearchClientsWithResponse(ctx context.Context, agencyId AgencyIdParam, params *SearchClientsParams, reqEditors ...RequestEditorFn) (*SearchClientsResponse, error) {
	rsp, err := c.SearchClients(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsResponse(rsp)
}

// GetAgencyOfficesWithResponse request returning *GetAgencyOfficesResponse
func (c *ClientWithResponses) GetAgencyOfficesWithResponse(ctx context.Context, agencyId AgencyIdParam, params *GetAgencyOfficesParams, reqEditors ...RequestEditorFn) (*GetAgencyOfficesResponse, error) {
	rsp, err := c.GetAgencyOffices(ctx, agencyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgencyOfficesResponse(rsp)
}

// ParseGetAgenciesResponse parses an HTTP response from a GetAgenciesWithResponse call
func ParseGetAgenciesResponse(rsp *http.Response) (*GetAgenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadAttachmentResponse parses an HTTP response from a UploadAttachmentWithResponse call
func ParseUploadAttachmentResponse(rsp *http.Response) (*UploadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateLogNoteResponse parses an HTTP response from a CreateLogNoteWithResponse call
func ParseCreateLogNoteResponse(rsp *http.Response) (*CreateLogNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReceiptsResponse parses an HTTP response from a CreateReceiptsWithResponse call
func ParseCreateReceiptsResponse(rsp *http.Response) (*CreateReceiptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReceiptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChangedClientsResponse parses an HTTP response from a GetChangedClientsWithResponse call
func ParseGetChangedClientsResponse(rsp *http.Response) (*GetChangedClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangedClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClientListResponse parses an HTTP response from a GetClientListWithResponse call
func ParseGetClientListResponse(rsp *http.Response) (*GetClientListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchClientsResponse parses an HTTP response from a SearchClientsWithResponse call
func ParseSearchClientsResponse(rsp *http.Response) (*SearchClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAgencyOfficesResponse parses an HTTP response from a GetAgencyOfficesWithResponse call
func ParseGetAgencyOfficesResponse(rsp *http.Response) (*GetAgencyOfficesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgencyOfficesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Office
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
